<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>PID制御体験ゲーム</title>

<style>
body { margin:0; font-family:Arial; display:flex; }
#left { width:70%; padding:10px; }
#right { width:30%; padding:10px; background:#f4f4f4; overflow:auto;}
canvas { background:#fff; border:1px solid #ccc; }

.button-group { display:flex; gap:5px; margin-bottom:10px; }
.button-group button {
    flex:1;
    padding:6px;
    border:1px solid #999;
    background:#eee;
    cursor:pointer;
}
.button-group button.active {
    background:#4CAF50;
    color:white;
    font-weight:bold;
}

input { width:100%; margin-bottom:8px; }
h3 { margin-bottom:5px; }
</style>
</head>

<body>

<div id="left">
<canvas id="graph" width="900" height="500"></canvas>
</div>

<div id="right">

<h3>参照入力</h3>
<div class="button-group" id="refButtons">
<button data-value="step" class="active">Step</button>
<button data-value="sine">Sine</button>
<button data-value="square">Square</button>
<button data-value="trapezoid">Trapezoid</button>
</div>

<h3>制御器</h3>
<div class="button-group" id="controllerButtons">
<button data-value="P" class="active">P</button>
<button data-value="PD">PD</button>
<button data-value="PI">PI</button>
<button data-value="PID">PID</button>
</div>

<h3>PIDゲイン</h3>
Kp <input type="number" id="kp" value="2" step="0.1">
Ki <input type="number" id="ki" value="0.5" step="0.1">
Kd <input type="number" id="kd" value="0.2" step="0.1">

<h3>制御対象</h3>
<select id="plantType">
<option value="first">一次遅れ系</option>
<option value="second">二次遅れ系</option>
<option value="delay">一次遅れ＋むだ時間</option>
</select>

<h3>閉ループ極</h3>
<div id="poleDisplay"></div>

</div>

<script>

const canvas=document.getElementById("graph");
const ctx=canvas.getContext("2d");

let dt=0.01;
let simTime=5;   // 横軸 0〜5秒
let refType="step";
let controllerType="P";

/* --- ボタン設定 --- */
function setupButtons(groupId, setter){
    const group=document.getElementById(groupId);
    group.querySelectorAll("button").forEach(btn=>{
        btn.onclick=()=>{
            group.querySelectorAll("button").forEach(b=>b.classList.remove("active"));
            btn.classList.add("active");
            setter(btn.dataset.value);
            simulate();  // 即再計算
        }
    });
}
setupButtons("refButtons", val=>refType=val);
setupButtons("controllerButtons", val=>controllerType=val);

/* --- 入力変更で即再計算 --- */
document.querySelectorAll("input, select").forEach(el=>{
    el.addEventListener("input", simulate);
});

/* --- 参照信号 --- */
function reference(t){
if(refType==="step") return t>0.5?1:0;
if(refType==="sine") return Math.sin(2*Math.PI*1*t);
if(refType==="square") return Math.sign(Math.sin(2*Math.PI*1*t));
if(refType==="trapezoid"){
let tau=t%2;
if(tau<0.5) return 2*tau;
if(tau<1) return 1;
if(tau<1.5) return 3-2*tau;
return 0;
}
}

/* --- 極計算 --- */
function computePoles(kp){
let plant=document.getElementById("plantType").value;
let text="";
if(plant==="first"){
let pole=-(1+kp);
text="極: "+pole.toFixed(3);
}
if(plant==="second"){
let a=1,b=0.5,c=1+kp;
let D=b*b-4*a*c;
if(D>=0){
let p1=(-b+Math.sqrt(D))/(2*a);
let p2=(-b-Math.sqrt(D))/(2*a);
text=`極1: ${p1.toFixed(3)} , 極2: ${p2.toFixed(3)}`;
}else{
let real=(-b/2).toFixed(3);
let imag=(Math.sqrt(-D)/2).toFixed(3);
text=`極: ${real} ± j${imag}`;
}
}
document.getElementById("poleDisplay").innerHTML=text;
}

/* --- シミュレーション --- */
function simulate(){

let kp=parseFloat(document.getElementById("kp").value);
let ki=parseFloat(document.getElementById("ki").value);
let kd=parseFloat(document.getElementById("kd").value);
let plant=document.getElementById("plantType").value;

let y=0,ydot=0,int=0,prev=0;
let delayBuf=[];
let data=[];

for(let t=0;t<simTime;t+=dt){
let r=reference(t);
let e=r-y;
int+=e*dt;
let d=(e-prev)/dt;

let u=0;
if(controllerType==="P") u=kp*e;
if(controllerType==="PD") u=kp*e+kd*d;
if(controllerType==="PI") u=kp*e+ki*int;
if(controllerType==="PID") u=kp*e+ki*int+kd*d;

prev=e;

if(plant==="first") y+=dt*(-y+u);
if(plant==="second"){ ydot+=dt*(-0.5*ydot-y+u); y+=dt*ydot;}
if(plant==="delay"){ delayBuf.push(u); let du=delayBuf.length>20?delayBuf.shift():0; y+=dt*(-y+du);}

data.push({t,r,y});
}

draw(data);
computePoles(kp);
}

/* --- グラフ描画 --- */
function draw(data){

ctx.clearRect(0,0,canvas.width,canvas.height);

let w=canvas.width;
let h=canvas.height;
let max=1.5;
let min=-1.5;

function sx(t){return t/simTime*w;}
function sy(y){return h-(y-min)/(max-min)*h;}

/* 軸 */
ctx.strokeStyle="black";
ctx.beginPath();
ctx.moveTo(0,sy(0));
ctx.lineTo(w,sy(0));
ctx.moveTo(0,0);
ctx.lineTo(0,h);
ctx.stroke();

/* 横軸目盛 */
ctx.fillStyle="black";
for(let i=0;i<=5;i++){
let x=sx(i);
ctx.fillText(i+" s",x,h-5);
ctx.beginPath();
ctx.moveTo(x,sy(0)-5);
ctx.lineTo(x,sy(0)+5);
ctx.stroke();
}

/* 縦軸目盛 */
for(let y=-1.5;y<=1.5;y+=0.5){
let py=sy(y);
ctx.fillText(y.toFixed(1),5,py);
ctx.beginPath();
ctx.moveTo(0,py);
ctx.lineTo(5,py);
ctx.stroke();
}

/* 参照信号 */
ctx.strokeStyle="blue";
ctx.beginPath();
data.forEach((d,i)=>{let x=sx(d.t),y=sy(d.r); i?ctx.lineTo(x,y):ctx.moveTo(x,y);});
ctx.stroke();

/* 出力 */
ctx.strokeStyle="red";
ctx.beginPath();
data.forEach((d,i)=>{let x=sx(d.t),y=sy(d.y); i?ctx.lineTo(x,y):ctx.moveTo(x,y);});
ctx.stroke();
}

simulate();

</script>

</body>
</html>